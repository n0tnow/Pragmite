package com.pragmite.ai;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Claude API client for generating refactored code.
 * Uses Anthropic's Messages API with claude-sonnet-4-5 model.
 *
 * @since 1.4.0
 */
public class ClaudeApiClient {

    private static final Logger logger = LoggerFactory.getLogger(ClaudeApiClient.class);
    private static final String API_ENDPOINT = "https://api.anthropic.com/v1/messages";
    private static final String API_VERSION = "2023-06-01";

    private final ApiConfig config;
    private final HttpClient httpClient;
    private final Gson gson;

    public ClaudeApiClient(ApiConfig config) {
        this.config = config;
        this.httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(config.getTimeoutSeconds()))
            .build();
        this.gson = new Gson();
    }

    /**
     * Generate refactored code using Claude API.
     *
     * @param aiPrompt The AI prompt generated by PromptGenerator
     * @param originalCode The original code snippet
     * @return RefactoredCode object with results
     */
    public RefactoredCode generateRefactoring(String aiPrompt, String originalCode) {
        if (!config.isValid()) {
            return RefactoredCode.builder()
                .successful(false)
                .errorMessage("API configuration is invalid. Please set CLAUDE_API_KEY environment variable.")
                .build();
        }

        try {
            logger.info("Calling Claude API for code refactoring...");

            // Build request payload
            String requestBody = buildRequestPayload(aiPrompt, originalCode);

            // Send HTTP request
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(API_ENDPOINT))
                .header("Content-Type", "application/json")
                .header("x-api-key", config.getApiKey())
                .header("anthropic-version", API_VERSION)
                .timeout(Duration.ofSeconds(config.getTimeoutSeconds()))
                .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                .build();

            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            // Handle response
            if (response.statusCode() == 200) {
                return parseResponse(response.body(), originalCode);
            } else {
                logger.error("Claude API error: HTTP {}", response.statusCode());
                logger.error("Response: {}", response.body());
                return RefactoredCode.builder()
                    .successful(false)
                    .errorMessage("API error: HTTP " + response.statusCode())
                    .build();
            }

        } catch (IOException | InterruptedException e) {
            logger.error("Failed to call Claude API", e);
            return RefactoredCode.builder()
                .successful(false)
                .errorMessage("Network error: " + e.getMessage())
                .build();
        }
    }

    /**
     * Build the JSON request payload for Claude API.
     */
    private String buildRequestPayload(String aiPrompt, String originalCode) {
        JsonObject payload = new JsonObject();
        payload.addProperty("model", config.getModel());
        payload.addProperty("max_tokens", 4096);

        // Build messages array
        JsonArray messages = new JsonArray();
        JsonObject message = new JsonObject();
        message.addProperty("role", "user");

        // Enhanced prompt for refactoring
        String fullPrompt = buildEnhancedPrompt(aiPrompt, originalCode);
        message.addProperty("content", fullPrompt);

        messages.add(message);
        payload.add("messages", messages);

        return gson.toJson(payload);
    }

    /**
     * Build enhanced prompt with clear instructions for structured output.
     */
    private String buildEnhancedPrompt(String aiPrompt, String originalCode) {
        return aiPrompt + "\n\n" +
            "Please provide your response in the following format:\n\n" +
            "## Refactored Code\n```java\n[your refactored code here]\n```\n\n" +
            "## Explanation\n[brief explanation of what you changed]\n\n" +
            "## Why This is Better\n[explain the benefits and improvements]\n\n" +
            "## Changes Made\n- [change 1]\n- [change 2]\n- [change 3]\n";
    }

    /**
     * Parse Claude API response and extract refactored code.
     */
    private RefactoredCode parseResponse(String responseBody, String originalCode) {
        try {
            JsonObject response = gson.fromJson(responseBody, JsonObject.class);
            JsonArray content = response.getAsJsonArray("content");

            if (content == null || content.size() == 0) {
                return RefactoredCode.builder()
                    .successful(false)
                    .errorMessage("Empty response from API")
                    .build();
            }

            // Extract text from first content block
            String text = content.get(0).getAsJsonObject().get("text").getAsString();

            // Parse the structured response
            return parseStructuredResponse(text, originalCode);

        } catch (Exception e) {
            logger.error("Failed to parse API response", e);
            return RefactoredCode.builder()
                .successful(false)
                .errorMessage("Failed to parse response: " + e.getMessage())
                .build();
        }
    }

    /**
     * Parse the structured response from Claude.
     */
    private RefactoredCode parseStructuredResponse(String text, String originalCode) {
        RefactoredCode.Builder builder = RefactoredCode.builder()
            .originalCode(originalCode)
            .successful(true);

        // Extract refactored code
        String refactoredCode = extractCodeBlock(text);
        if (refactoredCode != null) {
            builder.refactoredCode(refactoredCode);
        } else {
            builder.refactoredCode(text); // Fallback to full text
        }

        // Extract explanation
        String explanation = extractSection(text, "## Explanation", "## Why This is Better");
        if (explanation != null) {
            builder.explanation(explanation.trim());
        }

        // Extract why better
        String whyBetter = extractSection(text, "## Why This is Better", "## Changes Made");
        if (whyBetter != null) {
            builder.whyBetter(whyBetter.trim());
        }

        // Extract changes
        List<String> changes = extractChanges(text);
        changes.forEach(builder::addChange);

        return builder.build();
    }

    /**
     * Extract code block from markdown.
     */
    private String extractCodeBlock(String text) {
        Pattern pattern = Pattern.compile("```java\\s*\\n(.*?)\\n```", Pattern.DOTALL);
        Matcher matcher = pattern.matcher(text);
        if (matcher.find()) {
            return matcher.group(1).trim();
        }

        // Try without language specifier
        pattern = Pattern.compile("```\\s*\\n(.*?)\\n```", Pattern.DOTALL);
        matcher = pattern.matcher(text);
        if (matcher.find()) {
            return matcher.group(1).trim();
        }

        return null;
    }

    /**
     * Extract section between two headers.
     */
    private String extractSection(String text, String startHeader, String endHeader) {
        int start = text.indexOf(startHeader);
        if (start == -1) return null;

        start += startHeader.length();
        int end = text.indexOf(endHeader, start);
        if (end == -1) end = text.length();

        return text.substring(start, end).trim();
    }

    /**
     * Extract list of changes from "Changes Made" section.
     */
    private List<String> extractChanges(String text) {
        List<String> changes = new ArrayList<>();
        String changesSection = extractSection(text, "## Changes Made", "##");

        if (changesSection == null) return changes;

        // Extract bullet points
        Pattern pattern = Pattern.compile("^\\s*[-*]\\s+(.+)$", Pattern.MULTILINE);
        Matcher matcher = pattern.matcher(changesSection);

        while (matcher.find()) {
            changes.add(matcher.group(1).trim());
        }

        return changes;
    }
}
